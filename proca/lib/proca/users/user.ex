defmodule Proca.Users.User do
  @moduledoc """
  User schema generated by POW
  """
  use Ecto.Schema
  use Proca.Schema, module: __MODULE__
  use Pow.Ecto.Schema
  alias Proca.Users.StrongPassword
  alias Proca.{Repo, Users.User}
  import Ecto.Changeset, only: [change: 2]
  import Ecto.Query, only: [where: 3]

  schema "users" do
    pow_user_fields()

    has_many :staffers, Proca.Staffer
    field :perms, :integer


    timestamps()
  end

  @pow_config [otp_app: :proca]

  def pow_config do
    @pow_config
  end

  def get([email: email]) do 
    Pow.Operations.get_by([email: email], @pow_config)
  end

  def create!(email) do
    params = params_for(email)
    case Pow.Operations.create(params, @pow_config) do
      {:ok, user} -> %{user|password: params.password}
      {:error, _chset} -> raise "Cannot create user"
    end
  end

  def params_for(email) do
    pwd = StrongPassword.generate()

    %{
      email: email,
      password: pwd,
      password_confirmation: pwd
    }
  end

  def reset_password(email) do
    with u = %User{} <- get(email: email),
      new_pass <- StrongPassword.generate(),
      {:ok, u2} <- Pow.Ecto.Schema.Changeset.new_password_changeset(u, %{
        password:  new_pass}, @pow_config) 
        |> Repo.update()
      do
        {:ok, u2, new_pass}
      else
        nil -> {:error, "user not found"}
        err -> err
      end
    end

  def update(user, [:admin | kw]) do 
    update(user, [{:perms, [:instance_owner, :join_orgs, :manage_users, :manage_orgs]} | kw])
  end

  def update(user, [{:perms, permissions} | kw]) do 
    change(user, perms: Proca.Staffer.Permission.add(0, permissions))
    |> update(kw)

  end

  def update(user_change, []), do: Repo.update(user_change)

  def all(q, [{:email, email} | kw]) do 
    q |> where([u], u.email == ^email) |> all(kw)
  end

end
