defmodule Proca.Users.User do
  @moduledoc """
  User schema generated by POW
  """
  use Ecto.Schema
  use Proca.Schema, module: __MODULE__
  use Pow.Ecto.Schema
  alias Proca.Users.StrongPassword
  alias Proca.{Repo, Users.User}
  import Ecto.Changeset, only: [change: 2]
  import Ecto.Query, only: [from: 2, join: 4, where: 3, preload: 3]

  schema "users" do
    pow_user_fields()

    has_many :staffers, Proca.Staffer
    field :perms, :integer, default: 0

    timestamps()
  end

  @pow_config [otp_app: :proca]

  def pow_config do
    @pow_config
  end

  def get([email: email]) do 
    Pow.Operations.get_by([email: email], @pow_config)
  end

  def create!(email) do
    params = params_for(email)
    case Pow.Operations.create(params, @pow_config) do
      {:ok, user} -> %{user|password: params.password}
      {:error, _chset} -> raise "Cannot create user"
    end
  end

  def params_for(email) do
    pwd = StrongPassword.generate()

    %{
      email: email,
      password: pwd,
      password_confirmation: pwd
    }
  end

  def reset_password(email) do
    with u = %User{} <- get(email: email),
      new_pass <- StrongPassword.generate(),
      {:ok, u2} <- Pow.Ecto.Schema.Changeset.new_password_changeset(u, %{
        password:  new_pass}, @pow_config) 
        |> Repo.update()
      do
        {:ok, u2, new_pass}
      else
        nil -> {:error, "user not found"}
        err -> err
      end
    end

  def update(user, [:admin | kw]) do 
    update(user, [{:perms, [
      :instance_owner, 
      :join_orgs, 
      :manage_users, 
      :manage_orgs]} | kw])
  end

  def update(user, [{:perms, permissions} | kw]) do 
    change(user, perms: Proca.Permission.add(0, permissions))
    |> update(kw)
  end

  def all(q, [{:email, email} | kw]) do 
    q |> where([u], u.email == ^email) |> all(kw)
  end

  def all(q, [{:email_like, email} | kw]) do 
    q |> where([u], like(u.email, ^email)) |> all(kw)
  end

  def all(q, [{:id, id} | kw]) do 
    q |> where([u], u.id == ^id) |> all(kw)
  end

  def all(q, [{:org_name, org_name} | kw]) do 
    q 
    |> join(:inner, [u], s in assoc(u, :staffers))
    |> join(:inner, [u, s], o in assoc(s, :org))
    |> where([u, s, o], o.name == ^org_name)
    |> all(kw)
  end

  def all(q, [:preload | kw]) do 
    q |> preload([u], [staffers: :org]) |> all(kw)
  end
end
